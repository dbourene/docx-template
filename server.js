import express from 'express';
import cors from 'cors';
import fs from 'fs';
import { promises as fsPromises } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { exec } from 'child_process';
import { PDFDocument, rgb } from 'pdf-lib';
import { generateContrat } from './scripts/generateContrat.js';


// Configuration pour Docker/Render
const tempDir = path.join('/app', 'temp');
const PORT = process.env.PORT || 3001;

// Cr√©er le dossier temp au d√©marrage
if (!fs.existsSync(tempDir)) {
  fs.mkdirSync(tempDir);
  console.log('üìÅ Dossier temp cr√©√©');
}

// Bloc try/catch global pour √©viter les crashs
process.on('uncaughtException', (error) => {
  console.error('‚ùå ERREUR NON G√âR√âE:', error);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('‚ùå PROMESSE REJET√âE NON G√âR√âE:', reason);
  process.exit(1);
});

const app = express();
app.use(cors());
app.use(express.json());

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// V√©rification de LibreOffice au d√©marrage
const checkLibreOffice = () => {
  return new Promise((resolve) => {
    exec('libreoffice --version', (err, stdout, stderr) => {
      if (err) {
        console.error('‚ùå LibreOffice non disponible:', stderr || err.message);
        resolve(false);
      } else {
        console.log('‚úÖ LibreOffice d√©tect√©:', stdout.trim());
        resolve(true);
      }
    });
  });
};

// Function to wait for PDF file to be created
async function waitForPdfFile(pdfPath, maxRetries = 10, delayMs = 500) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      await fsPromises.access(pdfPath, fs.constants.F_OK);
      console.log(`‚úÖ PDF file found after ${i + 1} attempts`);
      return true;
    } catch (error) {
      console.log(`‚è≥ Waiting for PDF file... attempt ${i + 1}/${maxRetries}`);
      await new Promise(resolve => setTimeout(resolve, delayMs));
    }
  }
  throw new Error(`PDF file not created after ${maxRetries} attempts: ${pdfPath}`);
}

app.post('/generate', async (req, res) => {
  const { contrat_id, consommateur_id, producteur_id, installation_id } = req.body;

  try {
    console.log('üöÄ D√©but endpoint /generate');
    console.log('üìã Param√®tres re√ßus:', { contrat_id, consommateur_id, producteur_id, installation_id });

    // V√©rifier LibreOffice
    const libreOfficeOk = await checkLibreOffice();
    if (!libreOfficeOk) {
      throw new Error('LibreOffice non disponible pour la conversion PDF');
    }

    // 1. G√©n√©rer le fichier .docx
    console.log('üìÑ G√©n√©ration du fichier .docx...');
    const result = await generateContrat(contrat_id, consommateur_id, producteur_id, installation_id);
    
    console.log('‚úÖ R√©sultat g√©n√©ration contrat:', {
      success: result.success,
      fileName: result.fileName,
      hasBuffer: !!result.buffer,
      hasDocxBuffer: !!result.docxBuffer,
      bufferSize: result.buffer?.length || result.docxBuffer?.length
    });
    
    // R√©cup√©rer le buffer du fichier .docx
    const rawBuffer = result.buffer || result.docxBuffer;
    
    if (!rawBuffer) {
      throw new Error('Aucun buffer retourn√© par generateContrat');
    }

    // Conversion correcte du buffer
    const docxBuffer = Buffer.isBuffer(rawBuffer) ? rawBuffer : Buffer.from(rawBuffer);
    console.log('üì¶ Buffer r√©cup√©r√©, taille:', docxBuffer.length, 'bytes');

    // Chemins des fichiers dans /app/temp/
    const docxPath = path.join(tempDir, `contrat-${contrat_id}.docx`);
    const pdfPath = path.join(tempDir, `contrat-${contrat_id}.pdf`);

    console.log('üìÅ Chemins fichiers:');
    console.log('  DOCX:', docxPath);
    console.log('  PDF:', pdfPath);

    // 2. Sauvegarder le fichier .docx
    console.log('üíæ √âcriture du fichier .docx...');
    fs.writeFileSync(docxPath, docxBuffer);
    
    // V√©rifier que le fichier a bien √©t√© cr√©√©
    if (!fs.existsSync(docxPath)) {
      throw new Error('Fichier .docx non cr√©√© sur le disque');
    }
    
    const docxStats = fs.statSync(docxPath);
    console.log('‚úÖ Fichier .docx cr√©√© avec succ√®s:');
    console.log('  Chemin:', docxPath);
    console.log('  Taille:', docxStats.size, 'bytes');

    // 3. Convertir .docx ‚Üí .pdf avec LibreOffice
    console.log('üîÑ Conversion .docx ‚Üí .pdf avec LibreOffice...');
    const conversionCommand = `libreoffice --headless --convert-to pdf "${docxPath}" --outdir "${tempDir}"`;
    console.log('‚öôÔ∏è Commande LibreOffice:', conversionCommand);
    
    await new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('Timeout: Conversion PDF > 30 secondes'));
      }, 30000);

      exec(conversionCommand, (err, stdout, stderr) => {
        clearTimeout(timeout);
        console.log('üìã LibreOffice stdout:', stdout);
        if (stderr) {
          console.log('‚ö†Ô∏è LibreOffice stderr:', stderr);
        }
        
        if (err) {
          console.error('‚ùå Erreur conversion LibreOffice:', err);
          reject(new Error(`Erreur LibreOffice: ${stderr || err.message}`));
        } else {
          console.log('‚úÖ Commande LibreOffice termin√©e');
          resolve(stdout);
        }
      });
    });

    // 4. Attendre que le PDF soit cr√©√©
    console.log('‚è≥ Attente de la cr√©ation du fichier PDF...');
    await waitForPdfFile(pdfPath);
    
    // V√©rifier la taille du PDF cr√©√©
    const pdfStats = fs.statSync(pdfPath);
    console.log('‚úÖ PDF cr√©√© avec succ√®s:');
    console.log('  Chemin:', pdfPath);
    console.log('  Taille:', pdfStats.size, 'bytes');

    if (pdfStats.size === 0) {
      throw new Error('PDF g√©n√©r√© mais vide');
    }

    // 5. Charger le PDF et ajouter une signature visuelle
    console.log('üìñ Chargement du PDF pour signature...');
    const existingPdfBytes = fs.readFileSync(pdfPath);
    const pdfDoc = await PDFDocument.load(existingPdfBytes);
    const pages = pdfDoc.getPages();
    const firstPage = pages[0];

    // Ajouter une signature textuelle
    firstPage.drawText(`Sign√© √©lectroniquement - Contrat ${contrat_id}`, {
      x: 50,
      y: 50,
      size: 10,
      color: rgb(0, 0, 0),
    });

    const modifiedPdfBytes = await pdfDoc.save();
    console.log('‚úÖ Signature ajout√©e au PDF');

    // 6. Sauvegarder le PDF modifi√©
    fs.writeFileSync(pdfPath, modifiedPdfBytes);
    console.log('üíæ PDF sign√© sauvegard√©');

    // 7. Uploader le PDF dans Supabase Storage (m√™me emplacement que le .docx)
    const { createClient } = await import('@supabase/supabase-js');

    const supabase = createClient(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    );

    // Utiliser le m√™me nom que le .docx mais avec extension .pdf
    const pdfFileName = result.fileName.replace('.docx', '.pdf');
    const pdfStoragePath = `consommateurs/${pdfFileName}`;

    console.log('‚¨ÜÔ∏è Upload du PDF vers Supabase:', pdfStoragePath);

    const { error: uploadError } = await supabase.storage
      .from('contrats')
      .upload(pdfStoragePath, Buffer.from(modifiedPdfBytes), {
        contentType: 'application/pdf',
        upsert: true
      });

    if (uploadError) {
      console.error('‚ùå Erreur upload vers Supabase:', uploadError.message);
      throw new Error('Erreur lors de l‚Äôupload du fichier PDF dans Supabase');
    }

    // 8. Obtenir l'URL publique
    const { data: publicUrlData, error: publicUrlError } = supabase.storage
      .from('contrats')
      .getPublicUrl(pdfStoragePath);

    if (publicUrlError) {
      throw new Error('Erreur lors de la r√©cup√©ration de l‚ÄôURL publique du PDF');
    }

    const publicUrl = publicUrlData?.publicUrl;
    console.log('‚úÖ Fichier PDF upload√©. URL:', publicUrl);

    // 9. Mettre √† jour la table contrats apr√®s signature √©lectronique
    console.log('üîÑ Mise √† jour de la table contrats...');
    const { error: updateContratError } = await supabase
      .from('contrats')
      .update({
        url_consommateur: urlData.publicUrl,
        statut: 'attente_prod'
      })
      .eq('id', contrat_id);

    if (updateContratError) {
      console.error('‚ùå Erreur mise √† jour contrat:', updateContratError.message);
      throw new Error(`Erreur lors de la mise √† jour du contrat: ${updateContratError.message}`);
    }

    console.log('‚úÖ Contrat mis √† jour:');
    console.log('  - url_consommateur:', urlData.publicUrl);
    console.log('  - statut: attente_prod');

    // 10. R√©pondre au client
    console.log('üéâ Contrat g√©n√©r√© avec succ√®s:');
    console.log('  Fichier DOCX:', fs.existsSync(docxPath) ? 'Cr√©√©' : 'MANQUANT');
    console.log('  Fichier PDF:', fs.existsSync(pdfPath) ? 'Cr√©√©' : 'MANQUANT');
    
    res.status(200).json({
      success: true,
      fileName: pdfFileName,
      url: publicUrl,
      message: 'Contrat g√©n√©r√©, sign√© et upload√© dans Supabase avec succ√®s'
    });

    // 11. Nettoyage des fichiers temporaires
    setTimeout(() => {
      try {
        if (fs.existsSync(docxPath)) {
          fs.unlinkSync(docxPath);
          console.log('üßπ Fichier .docx temporaire supprim√©');
        }
        if (fs.existsSync(pdfPath)) {
          fs.unlinkSync(pdfPath);
          console.log('üßπ Fichier .pdf temporaire supprim√©');
        }
      } catch (cleanupError) {
        console.error('‚ö†Ô∏è Erreur lors du nettoyage:', cleanupError.message);
      }
    }, 2000);

  } catch (error) {
    console.error('‚ùå ERREUR ENDPOINT /generate:', error.message);
    console.error('‚ùå Stack trace:', error.stack);
    
    res.status(500).json({
      success: false,
      error: error.message,
      endpoint: '/generate'
    });
  }
});

// Endpoint pour convertir un .docx existant en PDF
app.post('/convert', async (req, res) => {
  const { contrat_id } = req.body;
  
  if (!contrat_id) {
    return res.status(400).json({ error: 'contrat_id manquant' });
  }

  console.log('üîÑ D√©but conversion PDF pour contrat:', contrat_id);

  try {
    // V√©rifier LibreOffice
    const libreOfficeOk = await checkLibreOffice();
    if (!libreOfficeOk) {
      throw new Error('LibreOffice non disponible pour la conversion PDF');
    }

    const { createClient } = await import('@supabase/supabase-js');
    const supabase = createClient(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    );

    const docxPath = path.join(tempDir, `contrat-${contrat_id}.docx`);
    const pdfPath = path.join(tempDir, `contrat-${contrat_id}.pdf`);

    // 1. Trouver le fichier .docx dans le bucket 'contrats'
    console.log('üîç Recherche du fichier .docx dans le bucket contrats...');
    
    const { data: files, error: listError } = await supabase.storage
      .from('contrats')
      .list('consommateurs', {
        search: `contrat-${contrat_id}`
      });

    if (listError) {
      throw new Error(`Erreur recherche fichier: ${listError.message}`);
    }

    const docxFile = files?.find(file => file.name.includes(`contrat-${contrat_id}`) && file.name.endsWith('.docx'));

    if (!docxFile) {
      throw new Error(`Fichier .docx non trouv√© pour le contrat ${contrat_id}`);
    }

    const docxStoragePath = `consommateurs/${docxFile.name}`;
    console.log('‚úÖ Fichier .docx trouv√©:', docxStoragePath);

    // 2. T√©l√©charger le .docx depuis Supabase Storage
    console.log('‚¨áÔ∏è T√©l√©chargement du .docx...');
    const { data: docxData, error: downloadError } = await supabase.storage
      .from('contrats')
      .download(docxStoragePath);

    if (downloadError) {
      throw new Error(`Erreur t√©l√©chargement .docx: ${downloadError.message}`);
    }

    // 3. Sauvegarder temporairement le .docx
    const arrayBuffer = await docxData.arrayBuffer();
    fs.writeFileSync(docxPath, Buffer.from(arrayBuffer));
    console.log('‚úÖ Fichier .docx sauvegard√© temporairement');

    // 4. Convertir .docx ‚Üí .pdf avec LibreOffice
    console.log('üîÑ Conversion .docx ‚Üí .pdf...');
    await new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('Timeout: Conversion PDF > 30 secondes'));
      }, 30000);

      exec(`libreoffice --headless --convert-to pdf "${docxPath}" --outdir "${tempDir}"`, (err, stdout, stderr) => {
        clearTimeout(timeout);
        if (err) {
          console.error('‚ùå Erreur LibreOffice:', stderr);
          return reject(err);
        }
        console.log('‚úÖ Conversion LibreOffice termin√©e');
        resolve(stdout);
      });
    });

    // 5. Attendre que le PDF soit cr√©√©
    await waitForPdfFile(pdfPath);

    // 6. Lire le PDF g√©n√©r√©
    console.log('üìñ Lecture du PDF g√©n√©r√©...');
    const pdfBuffer = fs.readFileSync(pdfPath);
    console.log('‚úÖ PDF lu, taille:', pdfBuffer.length, 'bytes');

    if (pdfBuffer.length === 0) {
      throw new Error('PDF g√©n√©r√© mais vide');
    }

    // 7. Uploader le PDF dans le bucket 'contrats', dossier 'consommateurs'
    const pdfFileName = docxFile.name.replace('.docx', '.pdf');
    const pdfUploadPath = `consommateurs/${pdfFileName}`;
    
    console.log('‚¨ÜÔ∏è Upload PDF vers:', pdfUploadPath);
    
    const { error: uploadError } = await supabase.storage
      .from('contrats')
      .upload(pdfUploadPath, pdfBuffer, {
        contentType: 'application/pdf',
        upsert: true
      });

    if (uploadError) {
      console.error('‚ùå Erreur upload PDF:', uploadError);
      throw new Error('Erreur upload PDF vers Supabase');
    }

    // 8. G√©n√©rer l'URL publique
    const { data: urlData } = supabase.storage
      .from('contrats')
      .getPublicUrl(pdfUploadPath);

    console.log('‚úÖ PDF upload√© avec succ√®s:', urlData.publicUrl);

    res.status(200).json({
      success: true,
      fileName: pdfFileName,
      url: urlData.publicUrl
    });

    // 9. Nettoyage des fichiers temporaires
    setTimeout(() => {
      try {
        if (fs.existsSync(docxPath)) fs.unlinkSync(docxPath);
        if (fs.existsSync(pdfPath)) fs.unlinkSync(pdfPath);
        console.log('üßπ Fichiers temporaires supprim√©s (/convert)');
      } catch (cleanupError) {
        console.error('‚ö†Ô∏è Erreur nettoyage:', cleanupError.message);
      }
    }, 2000);
    
  } catch (error) {
    console.error('‚ùå ERREUR ENDPOINT /convert:', error.message);
    console.error('‚ùå Stack trace:', error.stack);
    res.status(500).json({
      success: false,
      error: error.message,
      endpoint: '/convert'
    });
  }
});

// D√©marrer le serveur
app.listen(PORT, async () => {
  console.log(`üü¢ Serveur lanc√© sur le port ${PORT}`);
  console.log(`üåê URL: http://localhost:${PORT}`);
  console.log(`üìÅ Dossier temp: ${tempDir}`);
  
  // V√©rification initiale de LibreOffice
  const libreOfficeOk = await checkLibreOffice();
  if (!libreOfficeOk) {
    console.error('‚ö†Ô∏è ATTENTION: LibreOffice non disponible - les conversions PDF √©choueront');
  }
  
  console.log('üöÄ Serveur pr√™t √† traiter les requ√™tes');
});